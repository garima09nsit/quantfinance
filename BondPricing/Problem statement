{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# JMG Final Run - Bond Valuation\n",
    "\n",
    "We now graduate to doing something really serious... I mean, really really serious things that are relevant to our business - bond valuation. By the end of this week, you will know how to price a vanilla bond and be able to challenge the QARM team's calculation if they ever get it wrong! ^_^"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 1 - Payment Schedule\n",
    "\n",
    "When valuating fixed income instruments, we must first identify future cash flows.  Today's challenge is to build a payment schedule for a bond.\n",
    "\n",
    "1. Create a new Julia package called `BondPricing` (or Python module) for this marathon\n",
    "\n",
    "2. Define a struct (or class in Python) with\n",
    "  - cusip\n",
    "  - coupon (e.g. 0.03 means 3%)\n",
    "  - maturity date\n",
    "  - coupon frequency (e.g. 2 means semi-annual)\n",
    "\n",
    "3. Write a function `payment_schedule(bond, as_of_date)` that returns a DataFrame with the following columns:\n",
    "  - `date`: date of the cash flow\n",
    "  - `amount`: coupon payment, or coupon+principal for the last payment\n",
    "  - `days`: number of days between as of date and payment date\n",
    "  \n",
    "Requirements:\n",
    "- Your code must be able to handle coupon frequency of 1, 2, 4, and 12.\n",
    "\n",
    "Notes:\n",
    "- You can assume par amount of \\\\$1,000 (e.g. you get \\\\$20 for every period for a 4% semi-annual coupon bond)\n",
    "- Typically, a semi-annual coupon bond will pay coupon every 6 months on the same day of month.  For example, a bond maturing on 15-Aug-2028 will make coupon payments on 15-Feb and 15-Aug.\n",
    "\n",
    "Submit your solution by running the following code:\n",
    "\n",
    "```julia\n",
    "bond = Bond(\"TESTBOND2\", 0.04, Date(2028, 8, 15), 2)\n",
    "as_of_date = Date(2018, 8, 15)\n",
    "@show payment_schedule(bond, as_of_date)\n",
    "```\n",
    "\n",
    "The reuslt should look like this:\n",
    "```\n",
    "│ Row │ date       │ amount  │ days  │\n",
    "├─────┼────────────┼─────────┼───────┤\n",
    "│ 1   │ 2019-02-15 │ 20.0    │ 184   │\n",
    "│ 2   │ 2019-08-15 │ 20.0    │ 365   │\n",
    "│ 3   │ 2020-02-15 │ 20.0    │ 549   │\n",
    "...\n",
    "│ 19  │ 2028-02-15 │ 20.0    │ 3471  │\n",
    "│ 20  │ 2028-08-15 │ 1020.0  │ 3653  │\n",
    "```\n",
    "\n",
    "Just FYI:\n",
    "1. In many cases, we are not so certain about future cash flows. For example, for a mortgage-backed security, the borrower may prepay the loan and we end up receiving more cash than expected. Likewise, a corporate bond may be called before maturity date. \n",
    "\n",
    "2. In practice, if the payment date falls on a weekend or holiday then it needs to be adjusted to the following buisness date but for this exercise we can ignore that."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 2 - Pricing Technique\n",
    "\n",
    "A bond is valued as how investors perceives to obtain a certain yield.  Hence, the price of a bond is simply the net present value of all future cash flows discounted back to today based on an internal rate of return called _yield to maturity_.\n",
    "\n",
    "For a bond that pays annual coupon:\n",
    "$$\n",
    "PV = \\frac{C}{(1 + r)^1} + \\frac{C}{(1 + r)^2} + ... + \\frac{C + P}{(1 + r)^n}\n",
    "$$\n",
    "\n",
    "where \n",
    "$C$ = coupon, \n",
    "$P$ = principal,\n",
    "$r$ = yield to maturity,\n",
    "$n$ = number of periods\n",
    "\n",
    "To calculate $PV$ for a bond with semi-annual coupon (coupon frequency = 2), several adjustments must be made:\n",
    "\n",
    "* $C$ is divided by 2 \n",
    "* $r$ is divided by 2\n",
    "* $n$ is multiplied by 2 (so we have twice the number of terms than an annual coupon bond)\n",
    "\n",
    "The $\\frac{1}{(1 + r)^t}$ term in the above formula is called _discount factor_.\n",
    "\n",
    "**Task**\n",
    "\n",
    "1. Enhance the function `payment_schedule(bond::Bond, as_of_date::Date, yield::Float64)` to accept yield as a new argument.  Now, it must return the following columns:\n",
    "\n",
    "  - `date`: date of the cash flow\n",
    "  - `amount`: coupon payment, or coupon+principal for the last payment\n",
    "  - `days`: number of days between the as of date and the payment date\n",
    "  - (new) `discount_factor`: discount factor for the period\n",
    "  - (new) `value`: present value of the cash flow, which is simply amount multipled by discount factor\n",
    "\n",
    "2. Write a new function `price(bond::Bond, as_of_date::Date, yield::Float64)` that returns the price of the bond, as calculated below. You can assume par amount of \\\\$1,000 and round the result to 8 decimal places.\n",
    "\n",
    "$$\n",
    "Price = \\frac{PV}{ParAmount} * 100\n",
    "$$\n",
    "\n",
    "Test your code with the following:\n",
    "\n",
    "```julia\n",
    "bond = Bond(\"9128284V9\", 0.02875, Date(2028, 8, 15), 2)\n",
    "as_of_date = Date(2018, 8, 15)\n",
    "@show payment_schedule(bond, as_of_date, 0.02875)\n",
    "@show price(bond, as_of_date, 0.02875)\n",
    "```\n",
    "\n",
    "The result should look like:\n",
    "```\n",
    "│ Row │ date       │ amount  │ days  │ discount_factor │ value   │\n",
    "├─────┼────────────┼─────────┼───────┼─────────────────┼─────────┤\n",
    "│ 1   │ 2019-02-15 │ 14.375  │ 184   │ 0.985829        │ 14.1713 │\n",
    "│ 2   │ 2019-08-15 │ 14.375  │ 365   │ 0.971858        │ 13.9705 │\n",
    "│ 3   │ 2020-02-15 │ 14.375  │ 549   │ 0.958086        │ 13.7725 │\n",
    "...\n",
    "price(bond, as_of_date, 0.02875) = 100.0\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 3 - Full Price\n",
    "\n",
    "We had a problem in yesterday's implementation.  The formula assumes that the valuation date falls on a coupon date (or the issue date) because we discount the cash flows using full periods (1, 2, ..., $n$).  In practice, the valuation date is likely sometime in between coupon dates.\n",
    "\n",
    "To make it correct, we must adjust the discount factors to reflect partial periods.  \n",
    "\n",
    "First, let's define\n",
    "$$\n",
    "w = \\frac{DaysFromValuationDateToNextCouponDate}{DaysInCouponPeriod}\n",
    "$$\n",
    "\n",
    "Then, the exponents for the $PV$ formula is adjusted as follows:\n",
    "$$\n",
    "PV = \\frac{C}{(1 + r)^{w}} + \\frac{C}{(1 + r)^{1 + w}} + ... + \\frac{C + P}{(1 + r)^{n - 1 + w}}\n",
    "$$\n",
    "\n",
    "\n",
    "**The Task**\n",
    "\n",
    "Enhance your `payment_schedule` function to include `period` column and adjust `discount_factor` properly.  Test your code with the following bond.\n",
    "\n",
    "```\n",
    "bond = Bond(\"9128284V9\", 0.02875, 2028-08-15, 2)\n",
    "\n",
    "as_of_date = Date(2018, 11, 22) \n",
    "\n",
    "cash_flow(bond, as_of_date, 0.03067) = 20×6 DataFrame\n",
    "│ Row │ date       │ amount  │ days  │ discount_factor │ value   │ period   │\n",
    "├─────┼────────────┼─────────┼───────┼─────────────────┼─────────┼──────────┤\n",
    "│ 1   │ 2019-02-15 │ 14.375  │ 85    │ 0.992994        │ 14.2743 │ 0.461957 │\n",
    "│ 2   │ 2019-08-15 │ 14.375  │ 266   │ 0.977997        │ 14.0587 │ 1.46196  │\n",
    "│ 3   │ 2020-02-15 │ 14.375  │ 450   │ 0.963226        │ 13.8464 │ 2.46196  │\n",
    "...\n",
    "```\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 4 - Clean Price\n",
    "\n",
    "The clean price of a bond is simply the full price minus the accrued interest portion.\n",
    "So how do you calculate accrued interest?\n",
    "\n",
    "$$\n",
    "AccruedInterest = \\frac{DaysAccrued}{DaysInCouponPeriod} * Coupon\n",
    "$$\n",
    "\n",
    "**The Task**\n",
    "\n",
    "Refactor the `price` function that returns a tuple of full price and clean price.\n",
    "\n",
    "```\n",
    "bond = Bond(\"9128284V9\", 0.02875, Date(2028, 8, 15), 2)\n",
    "as_of_date = Date(2018, 11, 22)\n",
    "price(bond, as_of_date, 0.03067) = (full_price = 99.16592299, clean_price = 98.39248549)\n",
    "```"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.0.1",
   "language": "julia",
   "name": "julia-1.0"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.0.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
